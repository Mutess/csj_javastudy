package com.sist.main;

/* 
 		메모리 구조 
 		----------------------------------------------------------------------------------------
 		 MethodArea, static  ==> 컴파일러가 자동 저장
 		 method도 메모리에 저장
 		 void method() {
 		 }==> 메소드가 저장이 될려면 {구현부}이게 있어야 메모리에 저장됨
 		 void method(); ==> 이렇게 메소드만 선언된 경우에는 클래스를 저장하지 못한다. (미완성된 클래스)
 		 					(추상클래스, 인터페이스가 이 경우) ==> 요구사항 분석할 때가 이러한 경우를 사용
 		 							  ------- 데이터베이스 연결, 윈도우, 네트워크 서버, 웹구현
 		 							  
 		----------------------------------------------------------------------------------------
 		 Stack : LIFO
 		 		 지역변수, 매개변수 저장 => 메모리 자체에서 관리 ({}이 종료되면 사라진다.)
 		 		 class A 
 		 		 {
 		 		 	void method()
 		 		 	{
 		 		 		int a = 10;
 		 		 		if (a%2==0)
 		 		 		 {
 		 		 			int b = 20;
 		 		 			if (b==20) 
 		 		 			{
 		 		 				int c = 30;
 		 		 			}//c가 먼저 사라짐
 		 		 		}//b가 그 다음
 		 		 	}//c가 마지막으로 사라짐
 		 		 }
 		----------------------------------------------------------------------------------------
 		 Heap : 동적메모리 할당 (new) => 객체변수, 배열 (참조변수값)
 		 	    => 관리 (프로그래머) => GC(가비지 컬랙터(자동메모리 회수))
 		 	    => 객체 = null
 		 A.java ===> A.class ===>
 		 		javac		 java
 		 class A ==> 인터프리터 => 한줄씩 번역
 		 {
 		 	---
 		 	---
 		 	--- new 
 		 	---
 		 	---
 		 } => 읽다가 new가 나오면 그때 메모리 할당
 		----------------------------------------------------------------------------------------
 		변수 => stack
 			int a = 10;
 			0----------- 각 4byte씩
 				사용중
 			4-----------
 				사용중
 			8-----------
 				=> 값이 여기에 저장 => 10 ==> 메모리 주소에 대한 별칭 a
 			12-----------
 			
 		배열 (직렬로 저장)
 			--------------------
 				|	|	|	|
 			--------------------
 			
 			
 		클래스 (병렬로 저장)
 			--------------------
 			  ----------------
 			  		1
 			  ----------------
 			  	   "홍길동"
 			  ----------------
 			  	   "남자"
 			  ----------------
 			  	 getName()
 			  ----------------
 			  	 getSex()
 			  ----------------
 			--------------------
 		
 		클래스 
 		-----
 		1. 구성요소
 			1) 변수 => 60%가 변수를 잡는 것
 				= 인스턴스 변수 : 객체마다 메모리를 따로 저장
 							   => new를 이용해서 메모리 저장공간이 만들어진 경우
 				  A a = new A()
 				  	- 인스턴스 (객체)
 				  	a.변수명
 				= 정적변수 : 메모리 공간이 한개를 사용한다 (공유변수, 클래스변수)
 					- static   => 컴파일시 자동으로 생성
 					클래스명.변수명
 			-------------------------------메소드 호출시에 생성------------------------
 				= 지역변수 : 기능처리에 필요한 데이터를 설정(쓰고 버리는 변수 (인스턴스(멤버변수) : 사용후에도 유지되는 변수))
 				= 매개변수 : 사용자 요청값 => 메소드 종료와 동시에 사라진다.
 				-----------------변수는 반드시 초기화후 사용한다
 											----
 											자동 초기화 : 클래스 영역에 선언된 변수
 														인스턴스, 정적변수는 초기화된다.
 											초기화가 없는 경우 : 지역변수, 매개변수
 			   class A 
 			   {
 			   		String addr; => 지도를 받아오라고 했을떄 반드시 Addr이 있어야 함 //전역변수
 			   		void Address(String addr)
 			   		{
 			   			this.addr = addr
 			   			
 			   		}
 			   		void 지도출력() 
 			   		{
 			   			addr
 			   		}
 			   		void 근처맛집() 
 			   		{
 			   			addr
 			   		}
 			   }
 			2) 메소드 : 30% = 명령문의 집합 => 단락 (구조적인 프로그램)
 							반복수행 (제거) => 재사용 (한가지 기능수행)
 							다른 통신 담당
 			   1. 종류 
 			   	  인스턴스메소드 : 따로 작동하는 메소드 ==> ~에 대해서 제어해라
 			   	  	 String s = "Hello Java";
 			   	  	 s.substring()
 			   	  	 String s1 = "Hello Oracle";
 			   	  	 s1.substring() ==> 문자열마다 따로따로 제어해야하기 때문에 인스턴스
 			   	  	 
 			   	  정적메소드 : 동시에 작동할때 (static => 자동 저장) ==> 값을 가져와라 (ex : width, height) 가만히 있는것이 static
 			   	  	 10 => "10", true => "true" 제어하는 대상이 없기에 static
 			   	  	 String.valueOf(데이터형) 알아서 데이터를 바꿔줌
 			   	  	 Math.random()
 			   	  추상메소드 : 설계 => 모든 개발자가 같은 메소드를 제어
 			   	  				=> 표준화 작업
 			   	  				=> 여러개의 클래스를 묶어서 한개의 이름으로 제어
 			   	  				
 			   	  	  동물 => 먹는다, 걷는다..... => 동물
 			   	  	   |
 			   	 -------------
 			   	 |	   |     |
 			   	인간	   개	 말... : 설계(추상메소드)
 			   	
 			   	  종단메소드  : final void aaa() => (확장불가) 변경할 수 없는 메소드
 			3) 생성자 : 5%
 				= 객체 생성시 호출되는 메소드
 				= 멤버변수의 초기화
 				= 클래스명과 동일
 				= 생성자는 여러개 존재할 수 있다(오버로딩)
 				= 클래스안에 생성자를 반드시 구현하는 것은 아니다.
 					=> 기본 생성자를 추가한다
 					   -------- 매개변수가 없는 생성자
 					   
 			= 변수만 모아서 관리 : 사용자 정의 메소드형 (~VO, ~DTO, ~Bean)
 				getter / setter는 메소드 (변수의 기능 : 읽기/쓰기)
 			= 메소드만 모아서 관리 : 액션클래스 
 								~System, ~DAO, ~Manager, ~Service...
 			= 변수 + 메소드 : 조립
 						   ~Model, ~Controller(Spring), ~Action
 						   
 		2. 클래스 설계
 		   1. 기능 설계 : 메소드 추출
 		   2. 기능에서 사용하는 변수 추출
 		   3. 클래스 설계
 		   	  class ClassName {
 		   	  	변수
 		   	  	메소드
 		   	  	생성자
 		   	  }
 		   4. 메모리 저장
 		   	  ClassName c = new ClassName()
 		   5. 활용
 		   	  c.메소드()..
 		   6. 소멸
 		   	  c = null
 		3. 접근지정어
 		------------------------------------
 		 private : 자신의 클래스에서만 접근이 가능 => 데이터보호(캡슐화)
 		------------------------------------
 		 default : 같은 패키지안에서만 접근이 가능
 		------------------------------------
 		 protected : 같은 패키지안에서만 접근이 가능, 상속이 있는 경우 다른 패키지에서 접근이 가능
 		------------------------------------
 		 public : 패키지 상관없이 모든 클래스에 접근이 가능
 		------------------------------------
 		 멤버변수 [접근지정어] 데이터형 변수명
 		 메소드 [접근지정어][제어어] 리턴형 메소드명 (매개변수목록)
 		 		{		----- static, abstract, final
 		 		
 		 		}
 		 ==> 변수 : private
 		 	 메소드 : public
 		 	 생성자 : public
 		 	 
 		4. 객체지향의 특성
 			1) 캡슐화 => 데이터를 은닉화한후에 메소드를 통해서 접근 가능
 					   ------------- private => getter / setter
 			2) 재사용
 				=> 상속 (is - a) : 기존의 기능을 변경해서 사용
 					==> 개발자들이 겁이 많아서... 상속을 안씀
 					class A {
 					
 					}
 					class B extends A => 단일상속
 					
 				=> 포함 (has - a) : 기존의 기능을 있는 그대로 사용
 					class A {
 					
 					}
 					class B{
 						A a; ex) Scanner scan = new Scanner(system.in); String name;
 					}
 			3) 수정, 추가 => 다형성
 				오버라이딩 			오버로딩
 				---------------------------------------
 				메소드명 동일
 				---------------------------------------
 				상속관계				한개클래스/상속관계
 				---------------------------------------
 				매개변수 동일     	 	매개변수의 갯수 / 데이터형
 				---------------------------------------
 				리턴형 동일 			리턴형은 관계없다
 				---------------------------------------
 				접근 지정어 확장
 				  기능 수정			새로운 기능 추가
 				---------------------------------------
 		5. 제어자
 		   static / abstract / final (메소드에는 final을 사용안함)
 		   => static final : 상수
 		   => final : 상수형 변수 ==> 메소드안에서 사용이 가능
 		   	  ------- 사용하는 위치 (오라클 주소, 계정명, 비밀번호)
 */

public class 객체지향정리 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
