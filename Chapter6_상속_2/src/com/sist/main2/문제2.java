package com.sist.main2;

public class 문제2 {
/*
 		 1. 다음 중 생성자에 대한 설명으로 옳지 않은 것은? (모두 고르시오)  b,c 
 		 
		 a. 모든 생성자의 이름은 클래스의 이름과 동일해야한다.
		 b. 생성자는 객체를 생성하기 위한 것이다. ==> 생성자(X) ==> new
		 c. 클래스에는 생성자가 반드시 하나 이상 있어야 한다. (X) ==> 생성자는 없어도 상관없다.
		 												  -----------------이유 컴파일러가 자동으로 기본 생성자를 추가해주기 때문
		 d. 생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다.
		 e. 생성자는 오버로딩 할 수 없다.
				  ------- 같은 이름의 메소드를 여러개 만들어서 사용
				 					 = 여러개를 만들 수 있다.
				 			***오버로딩 조건
				 			= 한개의 클래스나 상속 관계의 클래스
				 			= 메소드명 동일
				 			= 매개변수의 갯수나 데이터형이 다르다.
				 			= 리턴형은 관계없다.
				 			
		class A {
			public void display(){}
			public void display(int a){}
		}
		class B extends A{
			//public void display(){}
			//public void display(int a){} //오버라이딩 (매개변수가 같으면 오버라이딩)
			public void display(int a, int b){} //오버로딩 (매개변수가 다르면 오버로딩)
		}

	

		this
		----
		1) 모든 클래스는 this를 가지고 있다.
		2) 객체 자신을 가르키는 참조변수 (static Object this) => new
		   => this는 생성자, 인스턴스 메소드에서 사용이 가능 (static은 사용불가)
		3) 클래스 내에서는 어디든지 사용이 가능(X) static 메소드에서는 사용이 불가능
		4) 지역변수와 인스턴스 변수를 구분할때 사용한다.
		   class A {
		   		private String name; ==> heap영역
		   		public void display(String name) => Stack
		   		{
		   			this.name = name (매개변수)
		   			----------
		   				A클래스에 설정된 변수
		   		}
		   }
		5) 클래스 메소드(static)에서는 사용할 수 없다.
		   인스턴스메소드, 객체메소드
		   	객체명.메소드
		   정적메소드, 공유메소드, 클래스 메소드
		    클래스명.메소드
		   -----------------------------
		  
		2. 다음 중 this에 대한 설명으로 맞지 않은 것은? (모두 고르시오) b
		
		a. 객체 자신을 가리키는 참조변수이다.
		b. 클래스 내에서라면 어디서든 사용할 수 있다. X
		c. 지역변수와 인스턴스변수를 구별할 때 사용한다.
		d. 클래스 메서드 내에서는 사용할 수 없다. 
=----------------------------------------------------------
		
			오버로딩 조건
			1) 메소드명이 동일 (한개의 이름으로 여러개의 새로운 기능을 추가)
			2) 매개변수의 갯수나 데이터형이 달라야 한다.
			3) 리턴형은 관계없다.
			4) 매개변수의 이름이 달라야 한다.
				void display(int a) ==> void display(int) 여기까지만 읽어서 상관없음
		3. 다음 중 오버로딩이 성립하기 위한 조건이 아닌 것은? (모두 고르시오) c, d
			a. 메서드의 이름이 같아야 한다.
			b. 매개변수의 개수나 타입이 달라야 한다.
			c. 리턴타입이 달라야 한다.
			d. 매개변수의 이름이 달라야 한다.
-------------------------------------------------------
		4. 다음 중 아래의 add메서드를 올바르게 오버로딩 한 것은? (모두 고르시오) b, c, d
		long add(int a, int b) { return a+b; }
														add(int, int) == 같은 메소드 그래서 a가 틀림
		a. long add(int x, int y) { return x+y; }		데이터형 자체가 달라야함
		b. long add(long a, long b) { return a+b; }
		c. int add(byte a, byte b) { return a+b; }
		d. int add(long a, int b) { return (int)(a+b); }

-------------------------------------------------------------------

		5. 다음 중 초기화에 대한 설명으로 옳지 않은 것은? (모두 고르시오) e
		a. 멤버변수는 자동 초기화되므로 초기화하지 않고도 값을 참고할 수 있다.
		   ------ 인스턴스 변수, 정적변수 => 자동 초기화
		   int => 0
		   double => 0.0
		   boolean => false
		   String => null (클래스, 배열)
		   null => 참조하는 주소가 없는 경우
		   => String s = null
		   if(s=null)
		   String s = "";
		   if (s.equals(""))
		b. 지역변수는 사용하기 전에 반드시 초기화해야 한다.
		   지역변수는 자동 초기화가 안된다. (반드시 초기화 후 사용)
		c. 초기화 블럭보다 생성자가 먼저 수행된다.
		   명시적 초기화 => 초기화 블록 => 생성자
		   				클래스변수 => 인스턴스 변수
		d. 명시적 초기화를 제일 우선적으로 고려해야 한다.
		   ---------- 명시적 초기화로 미리 값을 정해놓는 게 좋음
		
		e. 클래스변수보다 인스턴스변수가 먼저 초기화된다.
		   ---------컴파일시, new
		   클래스(static)이 더 먼저 초기화되고 ,인스턴스가 초기화가 됨
-----------------------------------------------------------------------
		다음 중 인스턴스변수의 초기화 순서가 올바른 것은? a
		
		a. 기본값-명시적초기화-초기화블럭-생성자 (기명초생)
						  -------
						  초기화중에서도 static => instance 클래스가 먼저고 다음 인스턴스가 그 다음으로 초기화가 됨
		b. 기본값-명시적초기화-생성자-초기화블럭
		c. 기본값-초기화블럭-명시적초기화-생성자
		d. 기본값-초기화블럭-생성자-명시적초기화
------------------------------------------------------------------------
		다음 중 지역변수에 대한 설명으로 옳지 않은 것은? (모두 고르시오) a,d,e
		
		a. 자동 초기화되므로 별도의 초기화가 필요없다.(X)
		b. 지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다.
		c. 메서드의 매개변수로 선언된 변수도 지역변수이다.
		d. 클래스변수나 인스턴스변수보다 메모리 부담이 적다.(X)
		e. 힙(heap)영역에 생성되며 가비지 컬렉터에 의해 소멸된다. (X) Stack에 들어가기 때문에 틀림
-------------------------------------------------------------------------------------
		다음 중 접근제어자를 접근범위가 넓은 것에서 좁은 것의 순으로 바르게 나열한 것은? b
		
		a. public-protected-(default)-private
		b. public-(default)-protected-private
		c. (default)-public-protected-private
		d. private-protected-(default)-public


		접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
		( private ) - 같은 클래스 내에서만 접근이 가능하다.
		( protected ) - 같은 패키지 내에서만 접근이 가능하다.
		( default ) - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
		( public ) - 접근 제한이 전혀 없다.
		
		다음 중 접근 제어자에 대한 설명으로 옳지 않은 것은? (모두 고르시오) c
		a. public은 접근제한이 전혀 없는 접근 제어자이다.
		b. (default)가 붙으면, 같은 패키지 내에서만 접근이 가능하다.
		c. 지역변수에도 접근 제어자를 사용할 수 있다.
		   ------
		   지역변수는 static, 접근지정어, abstract는 사용이 불가능
		   지역변수중에 유일하게 사용 : final
		d. protected가 붙으면, 같은 패키지 내에서도 접근이 가능하다.
		e. protected가 붙으면, 다른 패키지의 자손 클래스에서 접근이 가능하다.






 */
}
